
(*****************************************************************

	misc.net

 Miscelaneous functions in the Jaguar video chip.
 This includes interrupt management, timers and refresh

******************************************************************)

IMPORT	tosh,		(* Toshiba gate & pad definitions *)
	lego;


DEF MISC	(din[0..15],clk,resetl,
		pit0w, pit1w, int1w,int2w,intr,obint, gpuint, vint, dint,
		refrate[0..3], refback, ack, startref
		wet,pit0r,pit1r,tcount,test3r :IN;

		ihandler, tint, refreq, intl:IO;

                dr[0..15], mreq:BUS);

	INT16/tp,t,INT4/rc:IO;

(********************* INTERRUPTS ************************

In JAGUAR the fc[0..2] interrupt ack mechanism is used
In FALCON a simple iack input is used
In either case a single interrupt output is provided

There are six interrupt sources/signals

vint is an asynchronous pulse generated by the video logic on a specific pixel
gpuint is a synchronous pulse generated by the GPU writing to a register
obint is a synchronous pulse generated by the object processor stop instruction
tint is a synchronous pulse generated locally by a timer
dint is an edge triggered interrupt which is an input to the chip
it is intended for use with the DSP and should be at least one clock wide
*)

BEGIN

Vcc :=	TIE1 (vcc);

(************* the interrupt register **********)

Intw :=		AN2 (intw,int1w,wet);
Ie[0-4] :=	LDP2Q (ie[0-4],din[0-4],intw,resetl);

Ack[0-4] :=	AN2 (ack[0-4],din[8-12],int1w);

(* latch the video interrupt *)

Lvint :=	LSRB (lvint,vclr,vint);
Vclr :=		ND2 (vclr,resetl,ackl[0]);
Ackl[0] :=	IV (ackl[0],ack[0]);

(* sample the asynchronous interrupt sources to produce a synchronous pulse *)

Vi1 :=		FD2Q (vi1,lvint,clk,resetl);
Vi2 :=		FD2Q (vi2,vi1,clk,resetl);
Vi2l :=		IV (vi2l,vi2);
Vip :=		AN3 (vip,vi1,vi2l,ie[0]);

Gip :=		AN2 (gip,gpuint,ie[1]);
Oip :=		AN2 (oip,obint,ie[2]);
Tip :=		AN2 (tip,tint,ie[3]);

Di1 :=		FD2Q (di1,dint,clk,resetl);
Di2 :=		FD2Q (di2,di1,clk,resetl);
Di2l :=		IV (di2l,di2);
Dip :=		AN3 (dip,di1,di2l,ie[4]);

(* latch all the synchronised interrupts *)

I[0] :=		FJK2 (i[0],il[0],vip,ack[0],clk,resetl);
I[1] :=		FJK2 (i[1],il[1],gip,ack[1],clk,resetl);
I[2] :=		FJK2 (i[2],il[2],oip,ack[2],clk,resetl);
I[3] :=		FJK2 (i[3],il[3],tip,ack[3],clk,resetl);
I[4] :=		FJK2 (i[4],il[4],dip,ack[4],clk,resetl);

Ilu[0-4] :=	DUMMY (il[0-4]);

(* generate a CPU interrupt signal *)

Intl:=		NR6 (intl,i[0..4],gnd);

(* tristate the interrupt sources onto the bus for identification *)

Di[0-4] :=	TS (dr[0-4],i[0-4],intr);
Di[5-15] :=	TS (dr[5-15],gnd,intr);
Gnd :=		TIE0 (gnd);

(*
 signal ihandler is set by intl and cleared by int2w
 it is used to give the cpu greater bus priority during interrupts
*)

Notint2w :=	IV (notint2w,int2w);
Ihd0 :=		ND2 (ihd0,ihandler,notint2w);
Ihd :=		ND2 (ihd,ihd0,intl);
Ihandler :=	FD2Q (ihandler,ihd,clk,resetl);


(*********************** TIMER *******************)

(* generate write strobes for transparent latches *)

Pit0 :=		NIVH (pit0,pit0w);
Pit1 :=		AN2H (pit1,wet,pit1w);

Pd[0-15] :=	SLATCH (pd[0-15],din[0-15],clk,pit0);
Td[0-15] :=	LDP1Q (td[0-15],din[0-15],pit1);

(* enabled if pit0 is nz *)

Ten0 :=		OR8 (ten0,pd[0..7]);
Ten1 :=		OR8 (ten1,pd[8..15]);
Ten :=		OR2 (ten,ten0,ten1);
Presl :=	AN2U (presl,ten,resetl);

(* 16 stage prescaler *)

Tp[0] :=   DNCNT (tp[0],tpco[0],pd[0],clk,ten,tpld,presl);
Tp[1-7] := DNCNT (tp[1-7],tpco[1-7],pd[1-7],clk,tpco[0-6],tpld,presl);
Tp[8] :=   DNCNT (tp[8],tpco[8],pd[8],clk,tpc8,tpld,presl);
Tp[9-15] := DNCNT (tp[9-15],tpco[9-15],pd[9-15],clk,tpco[8-14],tpld,presl);
Tpu[0-15] := DUMMY (tp[0-15]);
Tpco[7] := DUMMY (tpco[7]);
Tpco[15] := DUMMY (tpco[15]);
Tplac0 :=	NR8 (tplac0,tp[0..7]);
Tplac1 :=	NR8 (tplac1,tp[8..15]);
Tpc8 :=		AN2 (tpc8,tplac0,ten);
Tpc16 :=	AN3 (tpc16,tplac0,tplac1,ten);

Tpldi := NR2 (tpldi,tpc16,pit0w);
Tpld :=	IVH (tpld,tpldi);

Dtp[0-15] :=	TS (dr[0-15],tp[0-15],pit0r);

(* 16 stage counter *)

T[0] :=	   DNCNT (t[0],tco[0],td[0],clk,tpc16,tld,presl);
T[1-7] := DNCNT (t[1-7],tco[1-7],td[1-7],clk,tco[0-6],tld,presl);
T[8] :=   DNCNT (t[8],tco[8],td[8],clk,tc8,tld,presl);
T[9-15] := DNCNT (t[9-15],tco[9-15],td[9-15],clk,tco[8-14],tld,presl);
Tu[0-15] := DUMMY (t[0-15]);
Tco[7] := DUMMY (tco[7]);
Tco[15] := DUMMY (tco[15]);
Tlac0 := 	NR8 (tlac0,t[0..7]);
Tlac1 :=	NR8 (tlac1,t[8..15]);
Tc8 :=		AN2 (tc8,tlac0,tpc16);
Tc16 :=		AN3 (tc16,tlac0,tlac1,tpc16);
Tldi :=	NR2 (tldi,tc16,pit1w);
Tld :=	IVH (tld,tldi);

Dt[0-15] :=	TS (dr[0-15],t[0-15],pit1r);

Tint :=		NIV (tint,tc16);

Tp :=		JOIN (tp,tp[0..15]);
T :=		JOIN (t,t[0..15]);
Rc :=		JOIN (rc,rc[0..3]);
Tpu :=		DUMMY (tp);
Tu :=		DUMMY (t);
Rcu :=		DUMMY (rc);



(**************************** REFRESH ************************)

(* divide the clock by 64 *)

Ps[0] :=	UPCNT1 (ps[0],psco[0],clk,vcc,resetl);
Ps[1-5] :=	UPCNT1 (ps[1-5],psco[1-5],clk,psco[0-4],resetl);
Pen :=		AN6 (pen,ps[0..5]);
Psco[5] :=	DUMMY (psco[5]);

(* refresh state machine

0	if (full) goto 1
	else if (startref && notempty) goto 1
	else goto 0

1	if (notempty){
		assert refreq, mreq
		if (refback && ack) assert dec
		goto 1
	}
	else goto 0

*)

Rq :=	FD2Q (rq,d0,clk,resetl);

D00 :=	ND2 (d00,notrq,full);
D01 :=	ND3 (d01,notrq,startref,notempty);
D02 :=	ND2 (d02,rq,notempty);
D0 :=	ND3 (d0,d00,d01,d02);

Refbreq := 	AN2 (refreq,rq,notempty);
Mreq :=		TS (mreq,refreq,refback);

Decl :=		ND2 (decl,refack,mreq);
Dec :=		IV (dec,decl);

(*
the refresh rate is determined by a four bit down counter 
this counter is clocked at clk/64 
*)

(* the counter may also be incremented by bit 0 of test1 *)

Rpcen :=	OR2 (rpcen,pen,tcount);

Rp[0] :=	DNCNT (rp[0],rpc[0],refrate[0],clk,rpcen,lrpc,resetl);
Rp[1-3] :=	DNCNT (rp[1-3],rpc[1-3],refrate[1-3],clk,rpc[0-2],lrpc,resetl);
Rpd[0-3] :=	DUMMY (rp[0-3]);
Rpc[3] :=	DUMMY (rpc[3]);

Rpl[0-3] :=	IV (rpl[0-3],rp[0-3]);
Lrpcl	:=	ND6 (lrpcl,rpl[0..3],rpcen,vcc);
Lrpc	:=	IVH (lrpc,lrpcl);

(* refresh is disabled if refrate = 0 *)

Rpenl :=	NR4P (rpenl,refrate[0..3]);
Rpen :=		IV (rpen,rpenl);

(*
The number of refresh cycles pending is stored in an eight bit counter
This counter is incremented by the carry from the previous counter
and decremented by refresh cycles
*)

Rc[0] :=	UDCNT1 (rc[0],rcc[0],clk,refcount,lrpc,resetl);
Rc[1-3] :=	UDCNT1 (rc[1-3],rcc[1-3],clk,rcc[0-2],lrpc,resetl);
Rcc[3] :=	DUMMY (rcc[3]);

(*
 enable the refresh counter onto the data bus for test
*)

Drc[0-3] :=	TS (dr[12-15],rc[0-3],test3r);

Rfc0 	:=	ND3 (rfc0,lrpc,rpen,decl);
Rfc1 	:=	ND2 (rfc1,lrpcl,dec);
Rfc2 	:=	ND2 (rfc2,rpenl,dec);
Refcount :=	ND3 (refcount,rfc0,rfc1,rfc2);

Full :=		NIV (full,rc[3]);
Notempty :=	OR4 (notempty,rc[0..3]);

Notrefack :=	ND2 (notrefack,refback,ack);
Refack :=	IV (refack,notrefack);

Notrq :=	IV (notrq,rq);

END;


