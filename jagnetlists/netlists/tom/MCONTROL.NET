/******************************************************************
mcontrol.net
27/3/91

Blitter Memory Interface Control Logic
--------------------------------------

******************************************************************/

IMPORT tosh;

DEF MCONTROL (
INT24/	blit_addr	/* blitter address */
	justify		/* data position on memory transfers */
	mreq		/* co-processor cycle request */
	width[0..3]	/* co-processor cycle width (in bytes) */
	read		/* co-processor read request */
	:BUS;
	active		/* memory interface active */
	blitack		/* memory acknowledge to the blitter */
	memidle		/* memory interface is idle */
	memready	/* memory interface is idle at next tick */
	read_ack	/* latch in data ack is active */
	wactive		/* write mreq active */
	:OUT;
	ack		/* memory controller acknowledge */
INT24/	address		/* address generated by address block */
	bcompen		/* bit selector inhibit enable */
	blit_back	/* blitter bus acknowledge */
	clk		/* co-processor clock */
	phrase_cycle	/* phrase operation at pipeline stage 1 */
	phrase_mode	/* phrase write mode */
	pixsize[0..2]	/* destination pixel size */
	pwidth[0..3]	/* width in phrase mode */
	readreq		/* memory cycle read request */
	reset\		/* system reset */
	sread[1]	/* source data read at pipe-line stage 1 */
	sreadx[1]	/* extra source data read at p-l stage 1 */
	step_inner	/* inner loop advance */
	writereq	/* memory cycle write request */
	:IN);
(* GE 19/06/2012 Added missing declarations *)
INT24/	blita
BEGIN


Ack\		:= IV (ack\, ack);
Pixsize\[0]	:= IV (pixsize\[0], pixsize[0]);
Pixsize\[2]	:= IV (pixsize\[2], pixsize[2]);

Busen		:= NIVU (busen, blit_back);

/* ack belongs to the blitter if the bus is granted to it */

Blitack\	:= ND2 (blitack\, ack, blit_back);
Blitack		:= IV (blitack, blitack\);

/* Memory interface read and write active decodes */

Ractvt0		:= ND2 (ractvt[0], ractive\, readreq);
Ractvt1		:= ND2 (ractvt[1], ractive, blitack\);
Ractvt2		:= ND3 (ractvt[2], ractive, blitack, readreq);
Ractvt3		:= ND3 (ractvt[3], ractvt[0..2]);
Ractive		:= FD2 (ractive, ractive\, ractvt[3], clk, 
			reset\);
Wactvt0		:= ND2 (wactvt[0], wactive\, writereq);
Wactvt1		:= ND2 (wactvt[1], wactive, blitack\);
Wactvt2		:= ND3 (wactvt[2], wactive, blitack, writereq);
Wactvt3		:= ND3 (wactvt[3], wactvt[0..2]);
Wactive		:= FD2 (wactive, wactive\, wactvt[3], clk, 
			reset\);

Active\		:= NR2 (active\, wactive, ractive);
Active		:= IV (active, active\);

/* the memory interface is ready when ack is true while active */

Memready	:= AN2 (memready, blitack, active);

Memidle		:= IV (memidle, active);

/* a cycle request is issued when either read or write cycle is 
active 
*/

Mreq		:= TSM (mreq, active, busen);

Read		:= TS (read, ractive, busen);

/* The width is given by the pixel size or phrase mode size
Normally, the system wide width is used when not in phrase mode,
however, source reads when bcompen is enabled force the width
to 1.
0001	(/pixsize[2] + fontread) . /phrase_cycle
0010	pixsize[2] . /pixsize[1] . /pixsize[0] . /phrase_cycle .
		/fontread
0100	pixsize[2] . /pixsize[1] . pixsize[0] . /phrase_cycle .
		/fontread
*/

Wt0t		:= NR2 (wt0t, pixsize\[2], fontread);
Wt0		:= NR2  (wt[0], wt0t, phrase_cycle);
Wt1		:= NR5 (wt[1], pixsize\[2], pixsize[1], 
			pixsize[0], phrase_cycle, fontread);
Wt2		:= NR5 (wt[2], pixsize\[2], pixsize[1], 
			pixsize\[0], phrase_cycle, fontread);
Pwrite		:= AN2 (pwrite, phrase_cycle, wactive);
Wout[0-2]	:= MX2 (wout[0-2], wt[0-2], pwidth[0-2], pwrite);
Wout[3]		:= MX2 (wout[3], phrase_cycle, pwidth[3], pwrite);

Width[0-3]	:= TS (width[0-3], wout[0-3], busen);

/* Justify is set when not in phrase mode, and also for the extra
source reads used to get data for bit-to-pixel expansion, 
therefore it is given by:
/phrase_mode + ((sread[1] + sreadx[1]) . bcompen) */

Fontread\	:= OND1 (fontread\, sread[1], sreadx[1], bcompen);
Fontread	:= IV (fontread, fontread\);

Justt		:= ND2 (justt, fontread\, phrase_mode);
Justify		:= TS (justify, justt, busen);

/* Enable the address out during blitter busack.
The address is pipe-lined here (as well as within addrgen) because
addrgen may have computed a new address before the previous one
has been used. */

Step_innerb	:= NIVU (step_innerb, step_inner);
Blita		:= FDSYNC24 (blita, address, step_innerb, clk);
Blit_addr	:= TSM (blit_addr, blita, busen);

/* Produce ACKs corresponding to valid read data.  A read is 
started by an ack where ractive and ack is true, and the data is
latched on the next ack - this may not belong to the blitter */

Waitackset	:= ND2 (waset\, ractive, blitack);
Wat0		:= ND2 (wat0, waitack, ack\);
Wat1		:= ND2 (wat1, waset\, wat0);
Waitack		:= FD2Q (waitack, wat1, clk, reset\);
Read_ack	:= AN2 (read_ack, waitack, ack);

END;
