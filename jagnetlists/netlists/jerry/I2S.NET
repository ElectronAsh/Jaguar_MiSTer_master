(*****************************************************************

	i2s.net

This module contains the I2S logic in Jerry

******************************************************************)

IMPORT 	tosh,		(* Toshiba gate & pad definitions *)
	lego;


DEF 	I2S	(resetl,clk,din[0..15],i2s1w,i2s2w,i2s3w,i2s4w,
		i2s1r,i2s2r,i2s3r,i2rxd,sckin,wsin:IN;

		i2txd,sckout,wsout,i2int,i2sen:IO;

		dr[0..15]:TRI;
INT16/ snd_l:OUT; INT16/ snd_r:OUT; snd_l_en,snd_r_en:OUT); (* GE *)

		INT8/t,INT5/b,INT4/bc:IO;
BEGIN

T	:=	JOIN (t,t[0..7]);
B	:=	JOIN (b,b[0..4]);
Bc	:=	JOIN (bc,bc[0..3]);
Pu	:=	DUMMY (t);
Bu	:=	DUMMY (b);
Bcu	:=	DUMMY (bc);

/*
 The logic in this module works in two modes
 in mode16 it behaves as a true 12s interface with a 16 bit
 word length. The start of left and right words are marked by
 transitions in word select. Interrupts are generated on rising edges
 of word select.
 in mode32 a rising edge on word select synchronizes the system
 which continues to receive 32 bit words. An interrupt is generated
 every 32 bits
*/
/*************** timing generator ***************/
/*
 the i2s clock and word select may be generated locally
 the clock is generated by dividing the system clock by 2-512
 word select is generated by dividing this by 32
*/

/* latch the divide ratio */

P[0-7] :=	STLATCHC (p[0-7],din[0-7],clk,i2s3w,resetl);

/* eight stage divider */

T[0] :=		DNCNT (t[0],tco[0],p[0],clk,vcc,tld,resetl);
T[1-7] :=	DNCNT (t[1-7],tco[1-7],p[1-7],clk,tco[0-6],tld,resetl);
Tldl :=		NR2 (tldl,tco[7],i2s3w);
Tld :=		IVM (tld,tldl);
Tu[0-7] :=	DUMMY (t[0-7]);

/* divide by two to get 50% duty cycle */

Sckout :=	SLATCHC (sckout,sckol,clk,tco[7],bresl);
Sckol :=	IV (sckol,sckout);
Ben :=		AN2 (ben,sckout,tco[7]);

/* divide by 32 to get word select */

B[0] :=		UPCNT1 (b[0],bco[0],clk,ben,bresl);
B[1-4] :=	UPCNT1 (b[1-4],bco[1-4],clk,bco[0-3],bresl);
Bu[0-3] :=	DUMMY (b[0-3]);
Bco[4] :=	DUMMY (bco[4]);
Bresl :=	AN2H (bresl,resetl,i2s3wl);
I2s3wl :=	IV (i2s3wl,i2s3w);

/* word select shares the same timing as b[4] each is enabled by wsen */

Wsod0 :=	ND3 (wsod0,bco[3],bl[4],wsen);
Wsod1 :=	ND2 (wsod1,wsout,notbco[3]);
Wsod :=		ND2 (wsod,wsod0,wsod1);
Wsi :=		FD2Q (wsout,wsod,clk,resetl);
Notbco[3] :=	IV (notbco[3],bco[3]);
Bl[4] :=	IV (bl[4],b[4]);


/* invert the incoming clock to provide 1/2 clock setup and hold */

Scks :=		MX2P (scks,sckin,sckout,i2sen);
Sck :=		NIVU (sck,scks);
Sckl :=		IVH (sckl,scks);

/************ receiver ***********
	   _____       _____       ______       ______
SCK	__/     \_____/     \_____/      \_____/      \___
	___ ______________________________________________
WS	___X______________________________________________
	___ ___________ ___________ ____________ _________
DATA	___X____LSB____X____MSB____X____________X_________
	                ___________
WSP	_______________/           \______________________

*/

/*
 generate an interrupt on the rising edge, falling edge or every msb
 to suit the application
*/

Wss :=		MX2P (wss,wsin,wsout,i2sen);
Ws :=		NIVH (ws,wss);
Wsl :=		IV (wsl,wss);
Ws[0] :=	FD2 (ws[0],wsl[0],ws,sck,resetl);
Ws[1] :=	FD2 (ws[1],wsl[1],ws[0],sck,resetl);
Wsp0 :=		ND3 (wsp0,ws[0],wsl[1],rising);
Wsp1 :=		ND3 (wsp1,wsl[0],ws[1],falling);
Wsp2 :=		ND2 (wsp2,msb,everyword);
Wsp :=		ND3 (wsp,wsp0,wsp1,wsp2);
I2sint :=	FD1Q (i2int,wsp,clk);
Wsu[1] :=	DUMMY (ws[1]);

/* reset a four bit counter from the sync edge */

Bci[0] :=	UPCNT1S (bci[0],bcco[0],sck,bcen,bcresl);
Bci[1-3] :=	UPCNT1S (bci[1-3],bcco[1-3],sck,bcco[0-2],bcresl);
Bcco[3] :=	DUMMY (bcco[3]);
Bcl[0-3] :=	IVM (bcl[0-3],bci[0-3]);
Bc[0-3] :=	IVM (bc[0-3],bcl[0-3]);

Bcres0 :=	ND2 (bcres0,wsl[0],ws);		/* leading edge either mode */
Bcres1 :=	ND3 (bcres1,ws[0],wsl,mode16);	/* falling edge 12s mode */
Bcres2 :=	ND2 (bcres2,lsb,mode32);	/* lsb in 32 bit mode */
Bcresl :=	AN4P (bcresl,bcres0,bcres1,bcres2,resetl);

Bcen 	:=	ND2 (bcen,mode16,ov);		/* enabled unless overflow */

/* set an overflow bit in i2s mode if more than 16 bits received */

Ovd0 :=		ND2 (ovd0,ov,bcresl);
Ovd1 :=		ND3 (ovd1,lsb,mode16,bcresl);
Ovd :=		ND2 (ovd,ovd0,ovd1);
Ov :=		FD1Q (ov,ovd,sck);
Ovl :=		IVH (ovl,ov);

/* need a left/right bit in mode32 */
/* ll && rr refer to the current serial data */

Leftd0 :=	ND2 (leftd0,wsl[0],ws);		/* set by leading edge */
Leftd1 :=	ND2 (leftd1,left,notlsb);	/* until lsb */
Leftd2 :=	ND2 (leftd2,right,lsb);		/* set by right lsb */
Leftd :=	ND3 (leftd,leftd0,leftd1,leftd2);
Left :=		FD1Q (left,leftd,sck);
Right :=	IV (right,left);

Ll :=		MX2 (ll,wsl[0],left,mode32);
Rr :=		IVH (rr,ll);

/* select one of sixteen latches */

Bit[14] :=	AN6 (bit[14],ovl,bcl[3],bcl[2],bcl[1],bc[0],vcc);
Bit[13] :=	AN6 (bit[13],ovl,bcl[3],bcl[2],bc[1],bcl[0],vcc);
Bit[12] :=	AN6 (bit[12],ovl,bcl[3],bcl[2],bc[1],bc[0],vcc);
Bit[11] :=	AN6 (bit[11],ovl,bcl[3],bc[2],bcl[1],bcl[0],vcc);
Bit[10] :=	AN6 (bit[10],ovl,bcl[3],bc[2],bcl[1],bc[0],vcc);
Bit[9] :=	AN6 (bit[9],ovl,bcl[3],bc[2],bc[1],bcl[0],vcc);
Bit[8] :=	AN6 (bit[8],ovl,bcl[3],bc[2],bc[1],bc[0],vcc);
Bit[7] :=	AN6 (bit[7],ovl,bc[3],bcl[2],bcl[1],bcl[0],vcc);
Bit[6] :=	AN6 (bit[6],ovl,bc[3],bcl[2],bcl[1],bc[0],vcc);
Bit[5] :=	AN6 (bit[5],ovl,bc[3],bcl[2],bc[1],bcl[0],vcc);
Bit[4] :=	AN6 (bit[4],ovl,bc[3],bcl[2],bc[1],bc[0],vcc);
Bit[3] :=	AN6 (bit[3],ovl,bc[3],bc[2],bcl[1],bcl[0],vcc);
Bit[2] :=	AN6 (bit[2],ovl,bc[3],bc[2],bcl[1],bc[0],vcc);
Bit[1] :=	AN6 (bit[1],ovl,bc[3],bc[2],bc[1],bcl[0],vcc);
Bit[0] :=	AN6 (bit[0],ovl,bc[3],bc[2],bc[1],bc[0],vcc);
/*
Msb :=		NIVH (msb,bit[15]);
*/
Msbl :=		IVH (msbl,msb);
Lsb :=		NIV (lsb,bit[0]);
Notlsb :=	IV (notlsb,lsb);

/* generate msb synchronously */

Msbd :=		NR2 (msbd,ovd,bcresl);
Msbi :=		FD1Q (msbi,msbd,sck);
Msb :=		NIVH (msb,msbi);

/* latch the serial data in one of sixteen latches */

Sd[15] :=	SLATCH (sd[15],i2rxd,sck,msb);
Sd[0-14] :=	SLATCHR (sd[0-14],i2rxd,sck,bit[0-14],msbl);

/* transfer this into one of two sixteen bit latches */

Lrd[0-15] :=	SLATCH (lrd[0-15],sd[0-15],sck,trrd);
Rrd[0-15] :=	SLATCH (rrd[0-15],sd[0-15],sck,trld);
Trrd :=		AN2H (trrd,msb,ll);
Trld :=		AN2H (trld,msb,rr);

/* enable onto bus when read */

Drr[0-15] :=	TS (dr[0-15],rrd[0-15],i2s1r);
Drl[0-15] :=	TS (dr[0-15],lrd[0-15],i2s2r);

/* enable ws onto bus when read */

Drws :=		TS (dr[0],ws,i2s3r);
Drleft :=	TS (dr[1],left,i2s3r);
Dru[2-15] :=	TS (dr[2-15],gnd,i2s3r);

/************** transmitter **************/

/* latch parallel data */

Dpl[0-15] :=	SLATCH (dpl[0-15],din[0-15],clk,i2s1w);
Dpr[0-15] :=	SLATCH (dpr[0-15],din[0-15],clk,i2s2w);
Dp[0-15] :=	MX2 (dp[0-15],dpl[0-15],dpr[0-15],rr);

/* select parallel or serial data for transmit shift register */

Ds[0] :=	MX2 (ds[0],gnd,dp[0],msb);
Ds[1-15] :=	MX2 (ds[1-15],qs[0-14],dp[1-15],msb);

Qs[0-15] :=	FD1Q (qs[0-15],ds[0-15],sckl);
I2txd :=	JOIN (i2txd,qs[15]);

/* latch control bits */

I2sen :=	SLATCHC (i2sen,din[0],clk,i2s4w,resetl);
Mode32 :=	SLATCH (mode32,din[1],clk,i2s4w);
Wsen :=		SLATCH (wsen,din[2],clk,i2s4w);
Rising :=	SLATCH (rising,din[3],clk,i2s4w);
Falling :=	SLATCH (falling,din[4],clk,i2s4w);
Everyword :=	SLATCH (everyword,din[5],clk,i2s4w);

Mode16 :=	IV (mode16,mode32);

Gnd :=	TIE0 (gnd);
Vcc :=	TIE1 (vcc);

(* GE *)
Snd_L := JOIN(snd_l, dpl[0..15]);
Snd_R := JOIN(snd_r, dpr[0..15]);
Snd_L_en := NIV(snd_l_en, i2s1w);
Snd_R_en := NIV(snd_r_en, i2s2w);

END;


