/******************************************************************
state.net
27/3/91

Top Level of the Blitter State Control Logic
--------------------------------------------

This block contains the inner and outer loop state machines and 
counters, and a lot of control logic.  The division of control
logic into sub-modules has grown to be a little arbitrary.
******************************************************************/

IMPORT acontrol, blitstop, dcontrol, inner, mcontrol, outer;

DEF STATE (
INT24/	blit_addr	/* blitter address */
	justify		/* data position on memory transfers */
	mreq		/* co-processor cycle request */
	width[0..3]	/* co-processor cycle width (in bytes) */
	read		/* co-processor read request */
	:BUS;
	gpu_dout[0..31]	/* readable port bus */
	:TRI;
	a1fracldi	/* A1 window pointer fractions add */
	a1ptrldi	/* A1 window pointer add */
	a2ptrldi	/* A2 window pointer add */
	addasel[0..2]	/* address adder input A select */
	addbsel[0..1]	/* address adder input B select */
	addqsel		/* select adder Q versus GPU data */
	adda_xconst[0..2] /* constants to add to X & Y */
	adda_yconst
	addareg		/* add register rather than constant */
	apipe		/* load address pipe-line latch */
	blit_breq[0..1]	/* blitter bus requests */
	blit_int	/* blitter interrupt to GPU */
	cmpdst		/* compare dest rather than source */
	daddasel[0..2]	/* data adder input A selection */
	daddbsel[0..2]	/* data adder input B selection */
	daddmode[0..2]	/* data adder mode */
	data_ena	/* enable write data */
	data_sel[0..1]	/* select data to write */
	dbinh\[0..7]	/* destination byte inhibit lines */
	dend[0..5]	/* end of changed write data zone */
	dpipe[0..1]	/* load computed data pipe-line latch */
	dstart[0..5]	/* start of changed write data zone */
	dstdread	/* destination data read load enable */
	dstzread	/* destination zed read load enable */
	gena2		/* generate A2 as opposed to A1 */
	lfu_func[0..3]	/* LFU mode control */
	daddq_sel       /* select adder output vs. GPU data */
	modx[0..2]	/* mask low bits of X during add */
	patdadd		/* pattern data gouraud add */
	patfadd		/* pattern fraction gouraud add */
	phrase_mode	/* phrase write mode */
	reset\		/* blitter system reset */
	srcdread	/* source data read load enable */
	srcshift[0..5]	/* source alignment shift */
	srcz1add	/* zed data gouraud add */
	srcz2add	/* zed fraction gouraud add */
	srczread	/* source zed read load enable */
	suba_x		/* address adder X subtract control */
	suba_y		/* address adder Y subtract control */
	zaddr		/* generate Z address */
	zmode[0..2]	/* Z comparator mode */
	zpipe[0..1]	/* load computed zed pipe-line latch */
	:OUT;
	a1_outside	/* A1 pointer is outside window bounds */
	a1_pixsize[0..2] /* A1 pixel size */
INT15/	a1_win_x	/* A1 window x size */
INT16/	a1_x		/* A1 x pointer */
	a1addx[0..1]	/* A1 address X update mode */
	a1addy		/* A1 address Y update mode */
	a1xsign		/* sign for A1 X address updates */
	a1ysign		/* sign for A1 Y address updates */
	a2_pixsize[0..2] /* A2 pixel size */
INT16/	a2_x		/* A2 x pointer */
	a2addx[0..1]	/* A2 address X update mode */
	a2addy		/* A2 address Y update mode */
	a2xsign		/* sign for A2 X address updates */
	a2ysign		/* sign for A2 Y address updates */
	ack		/* memory controller acknowledge */
INT24/	address		/* address generated by address block */
	big_pix		/* Pixel organisation is big-endian */
	blit_back	/* blitter bus acknowledge */
	clk		/* co-processor clock */
	cmdld		/* command register load */
	countld		/* load inner count register */
	dcomp[0..7]	/* data byte equal flags */
INT32/	gpu_din		/* GPU data bus */
	pixa[0..2]	/* bit part of address, un-pipe-lined */
	srcd[0..7]	/* bits to use for bit to byte expansion */
	statrd		/* blitter status read port */
	stopld		/* collsion stop register load */
	xreset\		/* external reset into the blitter */
	zcomp[0..3]	/* output from Z comparators */
	:IN);
(* GE 19/06/2012 Added missing declarations *)
INT16/	dstxp
BEGIN

/* Command register bits to outside world */

Zmode[0-2]	:= FDSYNC (zmode[0-2], gpu_din{18-20}, cmdld, 
			clk);
Lfu_func[0-3]	:= FDSYNCU (lfu_func[0-3], gpu_din{21-24}, cmdld, 
			clk);
Cmpdst		:= FDSYNC (cmpdst,  gpu_din{25}, cmdld, clk);
Bcompent	:= FDSYNC (bcompent, gpu_din{26}, cmdld, clk);
Bcompen		:= NIVM (bcompen, bcompent);
Dcompent	:= FDSYNC (dcompent, gpu_din{27}, cmdld, clk);
Dcompen		:= NIVH (dcompen, dcompent);
Bkgwren		:= FDSYNC (bkgwren, gpu_din{28}, cmdld, clk);
Srcshade	:= FDSYNC (srcshade, gpu_din{30}, cmdld, clk);

/* make the activity status readable */

Blit_idle	:= NR3 (blit_idle, blit_breq[0..1], blit_back);
Stat[0]		:= TS (gpu_dout[0], blit_idle, statrd);

/* Combined inhibit enable term for inner */

Inhibent	:= NR5 (inhibent, zmode[0..2], bcompen, dcompen);
Inhiben		:= NR3 (inhiben, inhibent, phrase_mode, bkgwren);

/* Inner loop control logic */

Inner		:= INNER (gpu_dout[2..10] gpu_dout[16..31] apipe 
			atick[0..1] aticki[0] data_ena 
			dest_cycle[1] dpipe[0..1] dsta_addi 
			dstdread dstzread dwrite dwrite[1] dzwrite 
			dzwrite1 gena2 icount[0..2] indone 
			inner0 readreq srca_addi srcdread 
			srcdreadd srcen srczread sread[1] 
			sreadx[1] step_inner writereq zaddr 
			zpipe[0..1] a1_outside blitack clk cmdld 
			countld dsta2 dstxp gourd gourz gpu_din 
			inhiben instart memidle 
			memready nowrite phrase_mode pixsize[0..2] 
			read_ack reset\ srcshade statrd wactive);

/* Outer loop control logic */

Outer		:= OUTER (gpu_dout[11..15], a1updatei, a1fupdatei, 
			a2updatei, blit_breq[0..1], blit_int, 
			instart, sshftld, active, clk, cmdld, 
			countld, gpu_din, indone, reset\, statrd, 
			stopped);

/* Memory interface control */

Mcontrol	:= MCONTROL (blit_addr, justify, mreq, width[0..3], read, 
			active, blitack, memidle, memready, read_ack, wactive, 
			ack, address, bcompen, blit_back, clk, phrase_cycle, 
			phrase_mode, pixsize[0..2], pwidth[0..3], readreq, 
			reset\, sread[1], sreadx[1], step_inner, writereq);

/* Address block control */

Acontrol	:= ACONTROL (addasel[0..2], addbsel[0..1], addqsel,
			adda_xconst[0..2], adda_yconst, addareg, 
			a1fracldi, a1ptrldi, a2ptrldi, dend[0..5],
			dsta2, dstart[0..5], dstxp, modx[0..2], 
			phrase_cycle, phrase_mode, pixsize[0..2], 
			pwidth[0..3], srcshift[0..5], suba_x, 
			suba_y, a1_pixsize[0..2], a1_win_x, a1_x, 
			a1addx[0..1], a1addy, a1xsign, a1ysign, 
			a1updatei, a1fupdatei, a2_pixsize[0..2], 
			a2_x, a2addx[0..1], a2addy, a2xsign, 
			a2ysign, a2updatei, atick[0..1], 
			aticki[0], bcompen, 
			clk, cmdld, dest_cycle[1], 
			dsta_addi, gpu_din, icount[0..2], inner0, 
			pixa[0..2], srca_addi, srcen, sshftld, 
			step_inner);

/* Data block control */

Dcontrol	:= DCONTROL (daddasel[0..2] daddbsel[0..2] 
			daddmode[0..2] data_sel[0..1] daddq_sel 
			gourd gourz patdadd patfadd srcz1add 
			srcz2add atick[0..1] clk cmdld dwrite 
			dzwrite dzwrite1 gpu_din srcdreadd 
			srcshade);

/* Comparator control */

Comp_ctrl	:= COMP_CTRL (dbinh\[0..7], nowrite, 
			bcompen, big_pix, bkgwren, clk, 
			dcomp[0..7], dcompen, icount[0..2], 
			pixsize[0..2], phrase_mode, srcd[0..7], 
			step_inner, zcomp[0..3]);

/* Collision stop control */

Blitstop	:= BLITSTOP (gpu_dout[1], stopped, reset\, 
			clk, dwrite[1], gpu_din, 
			nowrite, statrd, stopld, xreset\);

END;
